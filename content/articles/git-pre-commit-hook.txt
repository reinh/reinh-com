---
title:      Simple Git Continuous Integration
created_at: 2008-02-21 15:16:28.038512 -06:00
author:     Rein Henrichs
summary:    Wherein our hero demonstrates a simple way to keep yourself honest with your testing.
excerpt:    Preventing your developers (and yourself) from breaking the build is as simple as putting this in your .git/hooks/pre-commit and making it executable (@chmod +x .git/hooks/pre-commit@).
layout:     post
destination: 2008/02/21/simple-git-continuous-integration
filter:
  - haml
---

.hentry.entry
  .entry-title.column.span-15.first.last
    %h2.entry-title= @page.title   
  .entry-summary= @page.summary
  .post-info
    %abbr.published{:title => @page.created_at.to_s}= @page.created_at.strftime('%b %d, %Y')
  .entry-content
    :textile
      *Update:* It looks like Chris Wanstrath (of "Github":http://github.com fame) beat me to this one. Clearly, the git is strong with this one.

      Preventing your developers (and yourself) from breaking the build is as simple as putting this in your .git/hooks/pre-commit and making it executable (@chmod +x .git/hooks/pre-commit@).

          #!/bin/sh
          rake spec 2> /dev/null

      This will stop the commit if the specs don’t pass.

      bq. This isn’t a replacement for a more robust CI system but it makes it a lot harder to do something stupid. Redirecting STDERR to /dev/null is optional but recommended since the STDERR output of failing specs isn’t useful. It you use Test::Unit instead of RSpec (for shame), use rake test instead. Likewise, anything that returns proper error codes (0 for success, > 0 for failure) can be used.

      This is mainly useful if your specs take under a minute to run, otherwise it becomes tedious. If you have long-running specs, I suggest using a special task that runs an abridged set of core specs instead.
      